#+title: Lesson 12 — The Digital Twin Portal
#+subtitle: Where atlas, connectome, physiology, and simulation converge
#+author: bravli Collaboration
#+property: header-args:python :mkdirp yes
#+startup: showall

* What This Lesson Teaches

At the Blue Brain Project, the SSCx Portal was the culmination of a decade: a web
application where you could navigate from brain region to layer to morphological type
to synaptic pathway, with 3D visualizations, parameter tables, and validation data
linked at every level. The portal's structure /mirrored the reconstruction methodology
itself/ — traversing the portal was traversing the science.

FlyBrainLab took a different approach: five integrated panels in a single workspace,
where a natural-language query in the 3D viewer could populate an executable circuit
diagram connected to a simulator. The killer insight: the visualization /is/ the
simulation specification.

FlyWire Codex treated the connectome as a queryable database, with structured search
syntax and linked tables + 3D views.

Our portal borrows from all three:
- BBP's *methodology-as-navigation* — each tab follows the reconstruction pipeline
- FlyBrainLab's *simulation-in-the-loop* — explore anatomy, then stimulate it
- Codex's *data-first philosophy* — every view backed by a pandas DataFrame

But ours is different in a crucial way. Those portals present answers. Ours is
designed to /provoke questions/.

** The pedagogy of incomplete understanding

A brain contains ~10^{11} neurons (human) or ~10^{5} (fly). We simulate 139,255 of
them as dimensionless points with two state variables each. We collapse the
exquisite geometry of dendritic arbors into a single input resistance. We average
over the stochastic dance of vesicle release into a deterministic weight.

Every simplification is a question hiding in plain sight:

- The LIF equation $\tau_m \, dV/dt = -(V - V_{rest}) + g$ looks innocent. But why
  exponential decay? Because the membrane is an RC circuit — capacitance stores
  charge, resistance leaks it. And that's already a lie: real membranes have
  voltage-dependent conductances that make the leak nonlinear. Hodgkin and Huxley
  needed four differential equations where we use one. What did we lose?

- We use Euler integration with $\Delta t = 0.1$ ms. The ratio $\Delta t / \tau_m
  = 0.005$ makes this stable. But zoom in: at the moment of a spike, $V$ jumps
  discontinuously. No ODE solver handles discontinuities gracefully — they all
  interpolate across the threshold crossing. Brian2 uses "exact linear" integration
  between spikes, which is analytically correct for our equations. Our Euler is
  /not/ exact. When does this matter? (Hint: it matters for spike timing precision.
  And spike timing matters for STDP. And STDP matters for learning. And...)

- Zhang et al. showed that LIF, Izhikevich, and sigmoid models produce the same
  activation patterns on the FlyWire connectome. The network topology dominates.
  This is profound — but also suspicious. /When/ does the neuron model start to
  matter? At what level of analysis does the point-neuron approximation break?
  Surely timing-dependent computations (coincidence detection, phase coding)
  require more than a leaky bucket.

- We model graded-potential neurons by setting the threshold to +100 mV. But a
  real graded neuron has a continuous input-output function shaped by voltage-
  dependent potassium channels. The transfer function isn't a sigmoid — it's a
  dynamic nonlinearity that adapts. What computations in the optic lobe depend
  on this?

- Our synaptic weight is $w = \text{sign} \times n_{syn} \times W_{syn}$, where
  $W_{syn} = 0.275$ mV is the one free parameter Shiu tuned. But in reality,
  synaptic strength depends on vesicle pool size, release probability, receptor
  density, spine geometry, and recent history (STP). We have STP parameters in
  our physiology module — when you enable them, does the network behavior change
  qualitatively or just quantitatively?

The portal should make these questions /tangible/. When you look at a spike raster
and see suspiciously synchronous bursting, you should wonder: is this biology or a
Euler artifact? When you silence dopamine neurons and the mushroom body goes haywire,
you should wonder: would a conductance-based model predict the same?

The right reaction to the portal is not "I understand the fly brain now." It's
"I see five things I need to investigate."

** Learning Objectives

- [ ] Build an interactive multi-tab portal using Panel
- [ ] Wire existing bravli modules into reactive views
- [ ] Explore the FlyWire connectome from atlas to simulation
- [ ] /Feel/ the questions that arise from simplification
- [ ] Understand what the portal shows vs. what it hides

** File Map

| File                            | Role                                      |
|---------------------------------+-------------------------------------------|
| =bravli/portal/__init__.py=    | Subpackage exports                        |
| =bravli/portal/views.py=       | View-building functions for each tab      |
| =bravli/portal/app.py=         | Panel application assembly                |
| =tests/test_portal.py=         | Smoke tests for views                     |

* Implementation

** Portal subpackage init

#+begin_src python :tangle ../bravli/portal/__init__.py
"""portal — Interactive digital twin exploration.

A Panel-based application that wires bravli's atlas, connectivity,
physiology, and simulation modules into a navigable, reactive portal.

Launch with:
    panel serve bravli/portal/app.py
or in a notebook:
    from bravli.portal.app import build_portal
    portal = build_portal()
    portal.servable()

Requires: panel >= 1.0
"""

from .views import (
    atlas_view,
    composition_view,
    connectivity_view,
    physiology_view,
    simulate_view,
)
from .app import build_portal
#+end_src

** views.py — View builders

Each function returns a Panel component (column, row, or pane) that can be
embedded in a tab. Views are /lazy/ — they don't load data until the user
interacts with the relevant tab.

#+begin_src python :tangle ../bravli/portal/views.py
"""View-building functions for each portal tab.

Each view function takes data sources as arguments and returns
a Panel layout. Views are composable and testable independently.
"""

import numpy as np
import pandas as pd

try:
    import panel as pn
    HAS_PANEL = True
except ImportError:
    HAS_PANEL = False

try:
    import plotly.graph_objects as go
    HAS_PLOTLY = True
except ImportError:
    HAS_PLOTLY = False

from bravli.utils import get_logger

LOG = get_logger("portal.views")


def _require_panel():
    if not HAS_PANEL:
        raise ImportError(
            "Panel is required for the portal. Install with: pip install panel"
        )


def _empty_figure(title="No data"):
    """A placeholder plotly figure."""
    fig = go.Figure()
    fig.update_layout(
        title=title,
        template="plotly_dark",
        paper_bgcolor="#0d1117",
        plot_bgcolor="#0d1117",
    )
    return fig


# ---------------------------------------------------------------------------
# Tab 1: Atlas
# ---------------------------------------------------------------------------

def atlas_view(annotations, render_fn=None, detail_fn=None, neuropil_groups=None):
    """Build the atlas exploration tab.

    Parameters
    ----------
    annotations : pd.DataFrame
        FlyWire neuron annotations.
    render_fn : callable, optional
        Function(highlight_groups) -> go.Figure. If None, uses a placeholder.
    detail_fn : callable, optional
        Function(group) -> go.Figure for neuropil detail views.
    neuropil_groups : list of str, optional
        Available neuropil groups for the selector.

    Returns
    -------
    pn.Column
    """
    _require_panel()

    groups = neuropil_groups or [
        "(none)", "mushroom_body", "antennal_lobe", "central_complex",
        "lateral_horn", "superior_protocerebrum",
        "ventrolateral_protocerebrum",
        "medulla", "lobula", "lobula_plate", "lamina",
        "gnathal_ganglion",
    ]

    group_select = pn.widgets.Select(
        name="Highlight region", options=groups, value="(none)",
    )

    n_neurons = len(annotations)
    n_types = annotations["cell_type"].nunique() if "cell_type" in annotations.columns else "?"
    super_counts = ""
    if "super_class" in annotations.columns:
        top = annotations["super_class"].value_counts().head(5)
        super_counts = ", ".join(f"{k}: {v:,}" for k, v in top.items())

    info_md = pn.pane.Markdown(
        f"### FlyWire Connectome\n"
        f"- **{n_neurons:,}** neurons, **{n_types}** cell types\n"
        f"- Top super-classes: {super_counts}\n"
        f"- 78 neuropil compartments\n\n"
        f"*Select a region to highlight. Each neuropil is a question: "
        f"what computation does this geometry serve?*",
        styles={"color": "#c9d1d9"},
    )

    @pn.depends(group_select)
    def _atlas_plot(group):
        if render_fn is not None:
            try:
                highlight = [group] if group != "(none)" else None
                fig = render_fn(highlight_groups=highlight)
                return pn.pane.Plotly(fig, sizing_mode="stretch_both")
            except Exception as e:
                LOG.warning("Atlas render failed: %s", e)
        return pn.pane.Plotly(
            _empty_figure("Atlas (requires navis + fafbseg)"),
            sizing_mode="stretch_both",
        )

    @pn.depends(group_select)
    def _detail_plot(group):
        if detail_fn is not None and group != "(none)":
            try:
                fig = detail_fn(group)
                return pn.pane.Plotly(fig, sizing_mode="stretch_both")
            except Exception as e:
                LOG.warning("Detail render failed: %s", e)
        return pn.pane.Markdown(
            "*Select a region above to see its compartments.*",
            styles={"color": "#8b949e"},
        )

    return pn.Column(
        pn.pane.Markdown("# Atlas", styles={"color": "#c9d1d9"}),
        info_md,
        group_select,
        pn.Row(_atlas_plot, _detail_plot, sizing_mode="stretch_both"),
        sizing_mode="stretch_both",
    )


# ---------------------------------------------------------------------------
# Tab 2: Composition
# ---------------------------------------------------------------------------

def composition_view(annotations):
    """Build the composition exploration tab.

    Shows cell type distributions and neurotransmitter profiles
    per neuropil or super-class.
    """
    _require_panel()

    # Group-by selector
    groupby = pn.widgets.Select(
        name="Group by", options=["super_class", "cell_class", "cell_type"],
        value="super_class",
    )

    # NT filter
    nt_col = "top_nt" if "top_nt" in annotations.columns else None

    @pn.depends(groupby)
    def _composition_table(group_col):
        if group_col not in annotations.columns:
            return pn.pane.Markdown(f"*Column '{group_col}' not in annotations.*")
        counts = annotations[group_col].value_counts().head(30)
        df = counts.reset_index()
        df.columns = [group_col, "count"]
        return pn.pane.DataFrame(df, sizing_mode="stretch_width")

    @pn.depends(groupby)
    def _composition_bar(group_col):
        if group_col not in annotations.columns:
            return pn.pane.Plotly(_empty_figure("No data"))
        counts = annotations[group_col].value_counts().head(20)
        fig = go.Figure(go.Bar(
            x=counts.values,
            y=counts.index,
            orientation="h",
            marker_color="#58a6ff",
        ))
        fig.update_layout(
            title=f"Top 20 by {group_col}",
            template="plotly_dark",
            paper_bgcolor="#0d1117",
            plot_bgcolor="#0d1117",
            yaxis=dict(autorange="reversed"),
            height=500,
        )
        return pn.pane.Plotly(fig, sizing_mode="stretch_width")

    def _nt_pie():
        if nt_col and nt_col in annotations.columns:
            nt_counts = annotations[nt_col].value_counts()
            from bravli.viz.viz import NT_COLORS
            colors = [NT_COLORS.get(nt, "#888") for nt in nt_counts.index]
            fig = go.Figure(go.Pie(
                labels=nt_counts.index,
                values=nt_counts.values,
                marker=dict(colors=colors),
                hole=0.4,
            ))
            fig.update_layout(
                title="Neurotransmitter distribution",
                template="plotly_dark",
                paper_bgcolor="#0d1117",
                height=400,
            )
            return pn.pane.Plotly(fig)
        return pn.pane.Markdown(
            "*NT profile requires 'top_nt' column in annotations.*",
            styles={"color": "#8b949e"},
        )

    provocation = pn.pane.Markdown(
        "> *8,453 cell types — but how many are functionally distinct? "
        "The classification is morphological. Two neurons with identical "
        "branching patterns may express different ion channels, respond to "
        "different neuromodulators, sit in different activity regimes. "
        "The type is a hypothesis, not a fact.*",
        styles={"color": "#8b949e", "font-style": "italic"},
    )

    return pn.Column(
        pn.pane.Markdown("# Composition", styles={"color": "#c9d1d9"}),
        provocation,
        groupby,
        pn.Row(_composition_bar, _composition_table, sizing_mode="stretch_both"),
        _nt_pie(),
        sizing_mode="stretch_both",
    )


# ---------------------------------------------------------------------------
# Tab 3: Connectivity
# ---------------------------------------------------------------------------

def connectivity_view(edges=None):
    """Build the connectivity exploration tab.

    Parameters
    ----------
    edges : pd.DataFrame, optional
        Processed edge table (output of connectivity pipeline).
        If None, shows instructions for loading data.
    """
    _require_panel()

    if edges is None or len(edges) == 0:
        return pn.Column(
            pn.pane.Markdown("# Connectivity", styles={"color": "#c9d1d9"}),
            pn.pane.Markdown(
                "**No edge data loaded.** To populate this tab:\n\n"
                "```python\n"
                "from bravli.connectivity import load_edges, threshold_edges, "
                "assign_dominant_nt\n"
                "edges = load_edges('data/zenodo/proofread_connections_783.feather')\n"
                "edges = threshold_edges(edges)\n"
                "edges = assign_dominant_nt(edges)\n"
                "```\n\n"
                "Then pass `edges=edges` to `build_portal()`.",
                styles={"color": "#c9d1d9"},
            ),
        )

    # Neuropil selector
    neuropils = sorted(edges["neuropil"].unique()) if "neuropil" in edges.columns else []
    neuropil_select = pn.widgets.Select(
        name="Neuropil", options=["(all)"] + neuropils, value="(all)",
    )

    # Top-N slider
    top_n = pn.widgets.IntSlider(name="Top N pathways", start=5, end=50, value=20)

    @pn.depends(neuropil_select, top_n)
    def _pathway_table(neuropil, n):
        subset = edges if neuropil == "(all)" else edges[edges["neuropil"] == neuropil]
        top = (subset.groupby(["pre_pt_root_id", "post_pt_root_id"])
               .agg({"syn_count": "sum"})
               .reset_index()
               .nlargest(n, "syn_count"))
        return pn.pane.DataFrame(top, sizing_mode="stretch_width")

    @pn.depends(neuropil_select)
    def _synapse_histogram(neuropil):
        subset = edges if neuropil == "(all)" else edges[edges["neuropil"] == neuropil]
        syn = subset["syn_count"].values
        fig = go.Figure(go.Histogram(
            x=syn, nbinsx=50,
            marker_color="#f0883e",
        ))
        fig.update_layout(
            title=f"Synapse count distribution ({neuropil})",
            xaxis_title="Synapses per edge",
            yaxis_title="Count",
            template="plotly_dark",
            paper_bgcolor="#0d1117",
            plot_bgcolor="#0d1117",
            yaxis_type="log",
            height=400,
        )
        return pn.pane.Plotly(fig, sizing_mode="stretch_width")

    @pn.depends(neuropil_select)
    def _nt_breakdown(neuropil):
        subset = edges if neuropil == "(all)" else edges[edges["neuropil"] == neuropil]
        if "dominant_nt" not in subset.columns:
            return pn.pane.Markdown("*Run assign_dominant_nt() first.*")
        counts = subset.groupby("dominant_nt")["syn_count"].sum()
        from bravli.viz.viz import NT_COLORS
        colors = [NT_COLORS.get(nt, "#888") for nt in counts.index]
        fig = go.Figure(go.Bar(
            x=counts.index, y=counts.values,
            marker_color=colors,
        ))
        fig.update_layout(
            title=f"Synapses by NT type ({neuropil})",
            template="plotly_dark",
            paper_bgcolor="#0d1117",
            plot_bgcolor="#0d1117",
            height=350,
        )
        return pn.pane.Plotly(fig, sizing_mode="stretch_width")

    provocation = pn.pane.Markdown(
        "> *54.5 million synapses, but we threshold at $\\geq 5$ and discard 80% "
        "of edges. The weak connections we throw away — are they noise, or are "
        "they the substrate of neuromodulatory volume transmission, of slow "
        "learning, of context-dependent gating? The Dorkenwald threshold is a "
        "pragmatic choice, not a biological one.*",
        styles={"color": "#8b949e", "font-style": "italic"},
    )

    return pn.Column(
        pn.pane.Markdown("# Connectivity", styles={"color": "#c9d1d9"}),
        provocation,
        pn.Row(neuropil_select, top_n),
        pn.Row(_synapse_histogram, _nt_breakdown, sizing_mode="stretch_both"),
        _pathway_table,
        sizing_mode="stretch_both",
    )


# ---------------------------------------------------------------------------
# Tab 4: Physiology
# ---------------------------------------------------------------------------

def physiology_view(edges=None):
    """Build the synapse physiology exploration tab.

    Parameters
    ----------
    edges : pd.DataFrame, optional
        Edge table with physiology columns (from assign_synapse_models).
    """
    _require_panel()

    if edges is None:
        return pn.Column(
            pn.pane.Markdown("# Physiology", styles={"color": "#c9d1d9"}),
            pn.pane.Markdown(
                "**No physiology data.** Run the connectivity + physiology pipeline first.",
                styles={"color": "#c9d1d9"},
            ),
        )

    # Synapse model database summary
    from bravli.physiology.synapse_models import SYNAPSE_DB
    model_rows = []
    for name, model in SYNAPSE_DB.items():
        model_rows.append(model.to_dict())
    model_df = pd.DataFrame(model_rows)

    # Weight distribution
    has_weight = "weight" in edges.columns

    def _model_table():
        return pn.pane.DataFrame(model_df, sizing_mode="stretch_width")

    def _weight_dist():
        if not has_weight:
            return pn.pane.Markdown("*No 'weight' column — run compute_synaptic_weights().*")
        w = edges["weight"].dropna().values
        fig = go.Figure()
        fig.add_trace(go.Histogram(
            x=w[w > 0], name="Excitatory", marker_color="#58a6ff",
            nbinsx=50, opacity=0.7,
        ))
        fig.add_trace(go.Histogram(
            x=w[w < 0], name="Inhibitory", marker_color="#f85149",
            nbinsx=50, opacity=0.7,
        ))
        fig.update_layout(
            title="Synaptic weight distribution",
            xaxis_title="Weight (mV)",
            yaxis_title="Count",
            template="plotly_dark",
            paper_bgcolor="#0d1117",
            plot_bgcolor="#0d1117",
            barmode="overlay",
            height=400,
        )
        return pn.pane.Plotly(fig, sizing_mode="stretch_width")

    provocation = pn.pane.Markdown(
        "> *Every synapse gets the same $W_{syn} = 0.275$ mV per contact, "
        "modulated only by sign and count. In reality, a Kenyon cell synapse "
        "onto an MBON has been sculpted by hours of olfactory experience — "
        "depression here, potentiation there, a history written in bhosphated "
        "proteins and reshuffled AMPA receptors. Our model is amnesic. It has "
        "the connectome's anatomy but none of its biography.*",
        styles={"color": "#8b949e", "font-style": "italic"},
    )

    return pn.Column(
        pn.pane.Markdown("# Physiology", styles={"color": "#c9d1d9"}),
        provocation,
        pn.pane.Markdown("### Synapse Model Database", styles={"color": "#c9d1d9"}),
        _model_table(),
        pn.pane.Markdown("### Weight Distribution", styles={"color": "#c9d1d9"}),
        _weight_dist(),
        sizing_mode="stretch_both",
    )


# ---------------------------------------------------------------------------
# Tab 5: Simulate
# ---------------------------------------------------------------------------

def simulate_view(circuit=None):
    """Build the simulation tab.

    Parameters
    ----------
    circuit : Circuit, optional
        A pre-built circuit. If None, builds a small demo circuit.
    """
    _require_panel()

    from bravli.simulation.engine import simulate
    from bravli.simulation.stimulus import step_stimulus, poisson_stimulus
    from bravli.simulation.analysis import (
        firing_rates, spike_raster, population_rate, active_fraction,
    )

    # --- Demo circuit if none provided ---
    if circuit is None:
        from bravli.simulation.circuit import Circuit
        rng = np.random.RandomState(42)
        n = 100
        n_exc = 80
        n_inh = 20
        # Random sparse connectivity: ~5% density
        n_syn = 500
        pre = rng.randint(0, n, n_syn)
        post = rng.randint(0, n, n_syn)
        mask = pre != post
        pre, post = pre[mask], post[mask]
        weights = np.where(pre < n_exc, 0.5, -1.0) * rng.uniform(0.5, 1.5, len(pre))

        circuit = Circuit(
            n_neurons=n,
            v_rest=np.full(n, -52.0),
            v_thresh=np.full(n, -45.0),
            v_reset=np.full(n, -52.0),
            tau_m=np.full(n, 20.0),
            t_ref=np.full(n, 2.2),
            pre_idx=pre.astype(np.int32),
            post_idx=post.astype(np.int32),
            weights=weights,
            tau_syn=5.0,
            delay_steps=18,
        )

    # --- Widgets ---
    duration_slider = pn.widgets.IntSlider(
        name="Duration (ms)", start=100, end=2000, step=100, value=500,
    )
    n_stim = pn.widgets.IntSlider(
        name="Stimulated neurons", start=1, end=min(50, circuit.n_neurons),
        step=1, value=10,
    )
    stim_type = pn.widgets.Select(
        name="Stimulus", options=["poisson", "step"], value="poisson",
    )
    stim_strength = pn.widgets.FloatSlider(
        name="Stimulus strength", start=1.0, end=100.0, step=1.0, value=50.0,
    )
    run_button = pn.widgets.Button(name="Run simulation", button_type="primary")

    # --- Result storage ---
    result_holder = [None]

    status_md = pn.pane.Markdown(
        f"*Circuit: {circuit.n_neurons} neurons, {circuit.n_synapses} synapses. "
        f"Configure and press Run.*",
        styles={"color": "#c9d1d9"},
    )

    raster_pane = pn.pane.Plotly(_empty_figure("Spike raster (run simulation first)"))
    rate_pane = pn.pane.Plotly(_empty_figure("Population rate"))
    trace_pane = pn.pane.Plotly(_empty_figure("Voltage traces"))

    def _run(event):
        dur = duration_slider.value
        n_steps = int(dur / 0.1)
        targets = list(range(n_stim.value))

        if stim_type.value == "poisson":
            stim, _ = poisson_stimulus(
                circuit.n_neurons, n_steps, targets,
                rate_hz=stim_strength.value, weight=68.75, seed=42,
            )
        else:
            stim, _ = step_stimulus(
                circuit.n_neurons, n_steps, targets,
                amplitude=stim_strength.value,
                start_ms=50.0, end_ms=dur - 50.0,
            )

        status_md.object = "*Running...*"
        result = simulate(
            circuit, duration=dur, dt=0.1, stimulus=stim,
            record_v=True, record_idx=list(range(min(10, circuit.n_neurons))),
        )
        result_holder[0] = result

        # Raster
        times, neurons = spike_raster(result)
        fig_raster = go.Figure()
        if len(times) > 0:
            fig_raster.add_trace(go.Scattergl(
                x=times, y=neurons, mode="markers",
                marker=dict(size=2, color="#58a6ff"),
            ))
        fig_raster.update_layout(
            title=f"Spike raster — {result.n_spikes} spikes, "
                  f"mean {result.mean_rate():.1f} Hz",
            xaxis_title="Time (ms)", yaxis_title="Neuron index",
            template="plotly_dark",
            paper_bgcolor="#0d1117", plot_bgcolor="#0d1117",
            height=350,
        )
        raster_pane.object = fig_raster

        # Population rate
        t_bins, pop_rate = population_rate(result, bin_ms=10.0)
        fig_rate = go.Figure(go.Scatter(
            x=t_bins, y=pop_rate, mode="lines",
            line=dict(color="#f0883e", width=2),
        ))
        fig_rate.update_layout(
            title="Population firing rate",
            xaxis_title="Time (ms)", yaxis_title="Rate (Hz)",
            template="plotly_dark",
            paper_bgcolor="#0d1117", plot_bgcolor="#0d1117",
            height=300,
        )
        rate_pane.object = fig_rate

        # Voltage traces
        if result.v_trace is not None:
            fig_v = go.Figure()
            for i in range(min(5, result.v_trace.shape[0])):
                t_axis = np.arange(result.v_trace.shape[1]) * result.dt
                fig_v.add_trace(go.Scatter(
                    x=t_axis, y=result.v_trace[i],
                    mode="lines", name=f"Neuron {result.recorded_idx[i]}",
                    line=dict(width=1),
                ))
            fig_v.update_layout(
                title="Membrane potential (first 5 recorded neurons)",
                xaxis_title="Time (ms)", yaxis_title="V (mV)",
                template="plotly_dark",
                paper_bgcolor="#0d1117", plot_bgcolor="#0d1117",
                height=300,
            )
            trace_pane.object = fig_v

        frac = active_fraction(result, threshold_hz=1.0)
        status_md.object = (
            f"**Done.** {result.n_spikes} spikes, mean rate {result.mean_rate():.1f} Hz, "
            f"{frac*100:.1f}% neurons active (>1 Hz)."
        )

    run_button.on_click(_run)

    provocation = pn.pane.Markdown(
        "> *You are watching 100 differential equations evolve in time. "
        "Each spike is a threshold crossing — a discontinuity in a continuous "
        "dynamical system. The raster plot is a projection: it shows you /when/ "
        "neurons fire but hides /why/. The voltage traces show the subthreshold "
        "struggle — the tug-of-war between excitation and inhibition, between "
        "the leak current pulling toward rest and the synaptic current pushing "
        "toward threshold. Change the stimulus strength. Watch the transition "
        "from silence to sparse firing to synchronous bursting. Where is the "
        "phase transition? Is it sharp or gradual? Does it depend on the E/I "
        "ratio?*",
        styles={"color": "#8b949e", "font-style": "italic"},
    )

    return pn.Column(
        pn.pane.Markdown("# Simulate", styles={"color": "#c9d1d9"}),
        provocation,
        pn.Row(duration_slider, n_stim, stim_type, stim_strength),
        run_button,
        status_md,
        raster_pane,
        pn.Row(rate_pane, trace_pane, sizing_mode="stretch_both"),
        sizing_mode="stretch_both",
    )
#+end_src

** app.py — Application assembly

#+begin_src python :tangle ../bravli/portal/app.py
"""Assemble the bravli portal from individual views.

Usage:
    # In a notebook
    from bravli.portal.app import build_portal
    portal = build_portal()
    portal.servable()

    # As a standalone app
    panel serve bravli/portal/app.py --show
"""

import panel as pn

from bravli.utils import get_logger

LOG = get_logger("portal.app")


def build_portal(annotations=None, edges=None, circuit=None,
                 render_fn=None, detail_fn=None):
    """Build the complete portal application.

    Parameters
    ----------
    annotations : pd.DataFrame, optional
        FlyWire neuron annotations. If None, attempts to load from
        the default data path.
    edges : pd.DataFrame, optional
        Processed edge table (connectivity pipeline output).
    circuit : Circuit, optional
        Pre-built simulation circuit. If None, a demo circuit is used.
    render_fn : callable, optional
        Atlas rendering function (requires navis + fafbseg).
    detail_fn : callable, optional
        Neuropil detail rendering function.

    Returns
    -------
    pn.Tabs
        The complete portal, ready for .servable() or .show().
    """
    pn.extension("plotly", sizing_mode="stretch_width")

    from bravli.portal.views import (
        atlas_view,
        composition_view,
        connectivity_view,
        physiology_view,
        simulate_view,
    )

    # --- Load annotations if not provided ---
    if annotations is None:
        annotations = _try_load_annotations()

    # --- Build tabs ---
    tabs = []

    if annotations is not None:
        tabs.append(("Atlas", atlas_view(
            annotations, render_fn=render_fn, detail_fn=detail_fn,
        )))
        tabs.append(("Composition", composition_view(annotations)))
    else:
        tabs.append(("Atlas", pn.pane.Markdown(
            "# Atlas\n\n*No annotations loaded. Pass annotations=df to build_portal().*",
            styles={"color": "#c9d1d9"},
        )))

    tabs.append(("Connectivity", connectivity_view(edges=edges)))
    tabs.append(("Physiology", physiology_view(edges=edges)))
    tabs.append(("Simulate", simulate_view(circuit=circuit)))

    portal = pn.Tabs(*tabs, sizing_mode="stretch_both")

    LOG.info("Portal built: %d tabs", len(tabs))
    return portal


def _try_load_annotations():
    """Attempt to load FlyWire annotations from standard paths."""
    import os
    from pathlib import Path

    search_paths = [
        Path("data/flywire_annotations"),
        Path("../data/flywire_annotations"),
        Path.home() / "Darshan/research/develop/agentic/mayalucia/bravli/code/bravli/data/flywire_annotations",
    ]

    for base in search_paths:
        if base.is_dir():
            tsvs = list(base.glob("*.tsv"))
            if tsvs:
                import pandas as pd
                path = tsvs[0]
                LOG.info("Loading annotations from %s", path)
                return pd.read_csv(path, sep="\t")

    LOG.warning("Could not find FlyWire annotations. Pass annotations=df explicitly.")
    return None


# --- Standalone entry point ---
if __name__ == "__main__" or __name__.startswith("bokeh"):
    portal = build_portal()
    portal.servable()
#+end_src

* Tests

#+begin_src python :tangle ../tests/test_portal.py
"""Smoke tests for the portal module.

Tests that views can be constructed without errors.
Does NOT test Panel rendering (requires a browser).
"""

import numpy as np
import pandas as pd
import pytest

from bravli.simulation.circuit import Circuit


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------

@pytest.fixture
def sample_annotations():
    """Minimal annotation DataFrame."""
    return pd.DataFrame({
        "root_id": range(100),
        "super_class": np.random.choice(
            ["central", "optic", "sensory", "motor"], 100
        ),
        "cell_class": np.random.choice(
            ["KC", "PN", "MBON", "Mi", "T4"], 100
        ),
        "cell_type": [f"type_{i % 20}" for i in range(100)],
        "top_nt": np.random.choice(
            ["acetylcholine", "GABA", "glutamate"], 100
        ),
    })


@pytest.fixture
def sample_edges():
    """Minimal edge DataFrame."""
    rng = np.random.RandomState(42)
    n = 200
    return pd.DataFrame({
        "pre_pt_root_id": rng.randint(0, 50, n),
        "post_pt_root_id": rng.randint(0, 50, n),
        "neuropil": rng.choice(["MB", "AL", "LH"], n),
        "syn_count": rng.randint(1, 100, n),
        "dominant_nt": rng.choice(
            ["acetylcholine", "GABA", "glutamate"], n
        ),
        "weight": rng.uniform(-2.0, 2.0, n),
    })


@pytest.fixture
def demo_circuit():
    """Small demo circuit."""
    rng = np.random.RandomState(42)
    n = 20
    pre = rng.randint(0, n, 40).astype(np.int32)
    post = rng.randint(0, n, 40).astype(np.int32)
    mask = pre != post
    return Circuit(
        n_neurons=n,
        v_rest=np.full(n, -52.0),
        v_thresh=np.full(n, -45.0),
        v_reset=np.full(n, -52.0),
        tau_m=np.full(n, 20.0),
        t_ref=np.full(n, 2.2),
        pre_idx=pre[mask],
        post_idx=post[mask],
        weights=rng.uniform(-1, 1, mask.sum()),
        tau_syn=5.0,
        delay_steps=18,
    )


# ---------------------------------------------------------------------------
# Tests
# ---------------------------------------------------------------------------

class TestViews:
    def test_atlas_view(self, sample_annotations):
        from bravli.portal.views import atlas_view
        view = atlas_view(sample_annotations)
        assert view is not None

    def test_composition_view(self, sample_annotations):
        from bravli.portal.views import composition_view
        view = composition_view(sample_annotations)
        assert view is not None

    def test_connectivity_view_with_data(self, sample_edges):
        from bravli.portal.views import connectivity_view
        view = connectivity_view(edges=sample_edges)
        assert view is not None

    def test_connectivity_view_no_data(self):
        from bravli.portal.views import connectivity_view
        view = connectivity_view(edges=None)
        assert view is not None

    def test_physiology_view_with_data(self, sample_edges):
        from bravli.portal.views import physiology_view
        view = physiology_view(edges=sample_edges)
        assert view is not None

    def test_physiology_view_no_data(self):
        from bravli.portal.views import physiology_view
        view = physiology_view(edges=None)
        assert view is not None

    def test_simulate_view_with_circuit(self, demo_circuit):
        from bravli.portal.views import simulate_view
        view = simulate_view(circuit=demo_circuit)
        assert view is not None

    def test_simulate_view_demo(self):
        from bravli.portal.views import simulate_view
        view = simulate_view(circuit=None)
        assert view is not None


class TestApp:
    def test_build_portal_minimal(self, sample_annotations):
        from bravli.portal.app import build_portal
        portal = build_portal(annotations=sample_annotations)
        assert portal is not None

    def test_build_portal_full(self, sample_annotations, sample_edges, demo_circuit):
        from bravli.portal.app import build_portal
        portal = build_portal(
            annotations=sample_annotations,
            edges=sample_edges,
            circuit=demo_circuit,
        )
        assert portal is not None

    def test_build_portal_no_data(self):
        from bravli.portal.app import build_portal
        portal = build_portal()
        assert portal is not None
#+end_src

* Launching the Portal

To start exploring:

#+begin_src python :eval no
# In a Jupyter notebook or org-babel:
from bravli.portal import build_portal
portal = build_portal()
portal.show()  # opens in browser

# Or from the command line:
# panel serve bravli/portal/app.py --show
#+end_src

With real data:

#+begin_src python :eval no
import pandas as pd
from bravli.connectivity import load_edges, threshold_edges, assign_dominant_nt
from bravli.physiology import assign_synapse_models, compute_synaptic_weights

# Load annotations
annotations = pd.read_csv("data/flywire_annotations/file.tsv", sep="\t")

# Load and process edges
edges = load_edges("data/zenodo/proofread_connections_783.feather")
edges = threshold_edges(edges, min_syn=5)
edges = assign_dominant_nt(edges)
edges = assign_synapse_models(edges, mode="shiu")
edges = compute_synaptic_weights(edges, mode="shiu")

# Build and launch
from bravli.portal import build_portal
portal = build_portal(annotations=annotations, edges=edges)
portal.show()
#+end_src

* What the Portal Hides

Every visualization is a lie by omission. Here is an incomplete list of what
our portal does /not/ show:

** Spatial structure
The 3D atlas renders neuropil meshes, but the simulation treats neurons as
dimensionless points. The spatial arrangement of synapses along a dendrite —
which determines how inputs integrate (linearly near the soma, nonlinearly in
distal branches) — is invisible. The cable equation, which BBP spent years
optimizing for multicompartment models, is entirely absent. We could use it:
we have the skeletons. But at what cost in simulation speed? And what would
we gain in prediction accuracy?

** Temporal dynamics at short timescales
Our Euler timestep is 0.1 ms. Spike waveforms in Drosophila are ~1 ms wide.
We don't model the spike waveform at all — just the threshold crossing. But
the afterhyperpolarization (AHP) following a spike shapes the neuron's response
to subsequent inputs. Fast-spiking interneurons have brief AHPs; slow adapting
neurons have prolonged ones. Our refractory period is a crude approximation.
What would an adaptive exponential (AdEx) model add?

** Neuromodulation
Dopamine, serotonin, and octopamine are "modulatory" in our model — sign zero,
no fast PSP. But neuromodulation is how the brain changes /state/: sleep vs.
wake, hungry vs. satiated, aggressive vs. calm. A dopamine surge doesn't add
current — it changes the gain, the threshold, the time constants of downstream
neurons. Our model can't represent this. The portal shows you six neurotransmitter
types but only three of them /do/ anything in the simulation.

** Learning and plasticity
The connectome is a snapshot. The portal shows a frozen brain — no spike-timing-
dependent plasticity (STDP), no reward-modulated learning, no homeostatic
scaling. The mushroom body is the fly's learning center: Kenyon cell → MBON
synapses are sculpted by dopaminergic reinforcement signals over the animal's
lifetime. Our simulation uses the weights as measured, not as they would be
after an hour of olfactory conditioning. What would STDP do to the dynamics?

** Noise
Real neurons are stochastic: vesicle release is probabilistic, ion channels
open and close randomly, synaptic transmission fails ~50% of the time at some
synapses. Our model is deterministic (given the Poisson input). The only noise
is in the external drive. But neural noise isn't a nuisance — it can enhance
signal detection (stochastic resonance), decorrelate population activity
(balanced E/I networks), and enable exploration in decision-making. What
happens to our spike rasters if we add per-synapse release failure?

* Key Design Decisions

| Decision                                 | Rationale                                                                |
|------------------------------------------+--------------------------------------------------------------------------|
| Panel framework                          | Jupyter-native, reactive, plotly integration, zero infrastructure        |
| Five methodology-mirroring tabs           | BBP pattern: navigation encodes the science                              |
| Provocative marginalia in every tab      | The portal should generate questions, not answers                        |
| Demo circuit as fallback                 | Portal works without data files; accessible for first-time users         |
| Lazy data loading                        | Don't load 852 MB at import time; let user opt in                        |
| View functions return Panel objects      | Testable independently; composable; not coupled to tab layout            |

* Bibliography

- Markram H et al. (2015). NMC Portal. /Front Neural Circuits/ 9:44.
- Lazar AA et al. (2021). FlyBrainLab. /eLife/ 10:e62362.
- Dorkenwald S et al. (2024). FlyWire Codex. /Nature/ 634.
- HoloViz Panel. https://panel.holoviz.org

* Requirements for Agents                                        :noexport:

#+begin_src yaml :tangle no
lesson: 12-portal
tag: lesson/12-portal
files_created:
  - bravli/portal/__init__.py
  - bravli/portal/views.py
  - bravli/portal/app.py
  - tests/test_portal.py
verification:
  - "python -c 'from bravli.portal import build_portal' succeeds"
  - "pytest tests/test_portal.py -v — all tests pass"
next_lesson: null
#+end_src

* Local Variables                                                :noexport:

# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
